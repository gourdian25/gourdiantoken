// File: gourdiantoken/repository_factories.go
// This is a new shared file for both test and bench helpers

package gourdiantoken

import (
	"context"
	"testing"
	"time"

	"github.com/redis/go-redis/v9"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

// RepositoryFactory creates a TokenRepository and returns a cleanup function.
// It accepts a TB interface (implemented by both *testing.T and *testing.B).
type RepositoryFactory func(tb testing.TB) (TokenRepository, func())

// NewRepositoryFactories returns a map of all available repository factories.
// Each factory is keyed by repository type name and is ready to use in tests or benchmarks.
func NewRepositoryFactories() map[string]RepositoryFactory {
	return map[string]RepositoryFactory{
		"Memory":  newMemoryFactory(),
		"Redis":   newRedisFactory(),
		"MongoDB": newMongoDBFactory(),
		"GORM":    newGormFactory(),
	}
}

func newMemoryFactory() RepositoryFactory {
	return func(tb testing.TB) (TokenRepository, func()) {
		repo := NewMemoryTokenRepository(1 * time.Minute)
		cleanup := func() {
			if memRepo, ok := repo.(*MemoryTokenRepository); ok {
				if err := memRepo.Close(); err != nil {
					tb.Logf("Memory cleanup error: %v", err)
				}
			}
		}
		return repo, cleanup
	}
}

func newRedisFactory() RepositoryFactory {
	return func(tb testing.TB) (TokenRepository, func()) {
		redisAddr := "localhost:6379"
		redisPassword := "redis_password"

		client := redis.NewClient(&redis.Options{
			Addr:     redisAddr,
			Password: redisPassword,
			DB:       15,
		})

		ctx := context.Background()

		if err := client.Ping(ctx).Err(); err != nil {
			tb.Fatalf("Redis connection error: %v", err)
		}

		if err := client.FlushDB(ctx).Err(); err != nil {
			tb.Fatalf("Redis FlushDB error: %v", err)
		}

		repo, err := NewRedisTokenRepository(client)
		if err != nil {
			tb.Fatalf("Redis repository creation error: %v", err)
		}

		cleanup := func() {
			ctx := context.Background()
			if err := client.FlushDB(ctx).Err(); err != nil {
				tb.Logf("Redis cleanup FlushDB error: %v", err)
			}
			if err := client.Close(); err != nil {
				tb.Logf("Redis cleanup Close error: %v", err)
			}
		}
		return repo, cleanup
	}
}

func newMongoDBFactory() RepositoryFactory {
	return func(tb testing.TB) (TokenRepository, func()) {
		mongoURI := "mongodb://root:mongo_password@localhost:27017"

		ctx := context.Background()
		client, err := mongo.Connect(ctx, options.Client().ApplyURI(mongoURI))
		if err != nil {
			tb.Fatalf("MongoDB connection error: %v", err)
		}

		if err := client.Ping(ctx, nil); err != nil {
			tb.Fatalf("MongoDB ping error: %v", err)
		}

		db := client.Database("gourdian_test")

		_ = db.Collection("revoked_tokens").Drop(ctx)
		_ = db.Collection("rotated_tokens").Drop(ctx)

		repo, err := NewMongoTokenRepository(db, false)
		if err != nil {
			tb.Fatalf("MongoDB repository creation error: %v", err)
		}

		cleanup := func() {
			ctx := context.Background()
			_, _ = db.Collection("revoked_tokens").DeleteMany(ctx, bson.M{})
			_, _ = db.Collection("rotated_tokens").DeleteMany(ctx, bson.M{})

			if err := client.Disconnect(ctx); err != nil {
				tb.Logf("MongoDB cleanup Disconnect error: %v", err)
			}
		}
		return repo, cleanup
	}
}

func newGormFactory() RepositoryFactory {
	return func(tb testing.TB) (TokenRepository, func()) {
		postgresDSN := "host=localhost user=postgres_user password=postgres_password dbname=postgres_db port=5432 sslmode=disable"

		db, err := gorm.Open(postgres.Open(postgresDSN), &gorm.Config{})
		if err != nil {
			tb.Fatalf("GORM connection error: %v", err)
		}

		_ = db.Exec("TRUNCATE TABLE revoked_tokens RESTART IDENTITY CASCADE")
		_ = db.Exec("TRUNCATE TABLE rotated_tokens RESTART IDENTITY CASCADE")

		repo, err := NewGormTokenRepository(db)
		if err != nil {
			tb.Fatalf("GORM repository creation error: %v", err)
		}

		cleanup := func() {
			_ = db.Exec("TRUNCATE TABLE revoked_tokens RESTART IDENTITY CASCADE")
			_ = db.Exec("TRUNCATE TABLE rotated_tokens RESTART IDENTITY CASCADE")

			if gormRepo, ok := repo.(*GormTokenRepository); ok {
				if err := gormRepo.Close(); err != nil {
					tb.Logf("GORM cleanup Close error: %v", err)
				}
			}
		}
		return repo, cleanup
	}
}

// ============================================================================

// File: gourdiantoken/token.test.helper.go

func getTestRepositoryFactories() map[string]RepositoryFactory {
	return NewRepositoryFactories()
}

// ============================================================================

// File: gourdiantoken/token.bench.helper.go

func getBenchRepositoryFactories() map[string]RepositoryFactory {
	return NewRepositoryFactories()
}
